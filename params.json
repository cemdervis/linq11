{
  "name": "Linq11",
  "tagline": "LINQ for C++11",
  "body": "# linq11 - LINQ for C++11\r\n\r\nlinq11 is a header-only LINQ library for C++11 with minimal dependencies.\r\nIt neatly integrates into the STL and takes advantage of C++11 features, mainly the range-based for loop and lambda functions.\r\n\r\n_Example_:\r\n```cpp\r\n#include <iostream>\r\n#include <string>\r\n#include <vector>\r\n#include \"linq.h\"\r\n\r\nusing namespace std;\r\n\r\nstruct Person\r\n{\r\n    string Name;\r\n    int Age;\r\n};\r\n\r\nint main()\r\n{\r\n    vector<Person> people = {\r\n        { \"P1\", 20 },\r\n        { \"P2\", 21 },\r\n        { \"P3\", 22 }\r\n    };\r\n\r\n    auto query = linq::from(&people)\r\n        .where([](const Person& p) { return p.Age > 20; });\r\n\r\n    for (const auto& p : query)\r\n    {\r\n        cout << p.Name << \", \" << p.Age << endl;\r\n    }\r\n\r\n    return 0;\r\n}\r\n```\r\n\r\n_Output_:\r\n```\r\nP2, 21\r\nP3, 22\r\n```\r\n\r\nlinq11...\r\n- resolves all type related functionality at compile-time; no virtual dispatch is used\r\n- uses lazy evaluation, so your queries still work even after you modify the container it's based on\r\n- is extremely efficient in the way it works with your data; it avoids making copies and passes by reference wherever it can\r\n- does not maintain a flat list of operators in your query, but rather generates a linked-list at compile time\r\n- does not use exceptions\r\n- does not use boost or any other library\r\n- works with everything that behaves like an STL container. So vector, maps, strings, ...\r\n- tries to notify the user of errors at compile-time whenever it can (static_assert)\r\n- is licensed under the MIT license\r\n- uses the beloved dot operator!\r\n\r\nPlease take a look at the [Wiki](https://github.com/cemdervis/linq11/wiki) for the list of supported operators and their usage.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}